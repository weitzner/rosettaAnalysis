
# *************************************************
#                     Utilities
# *************************************************
disc.score <- function(x_col, y_col, divs) {
  disc.score <- 0
  for (div in divs) {
    left <- y_col[x_col <= div]
    left.of.div <- ifelse(length(left), min(left), 0.0)
    
    right <- y_col[x_col > div]
    right.of.div <- ifelse(length(right), min(right), 0.0)
    
    disc.score <- disc.score + (left.of.div - right.of.div)
  }
  return(disc.score / length(disc.divs))
}


#' Calculate the discrimination score for each cutoff
#'
#' 
#'
#' @param df Data frame containing the score data from a set of models generated by Rosetta
#' @param disc.divs RMSD cutoffs to use for .
#' @return A data.frame with the discrimination score for each target in the input data.frame.
#' @examples
#' d.scores <- discrimination.scores(score.data, groups = c("label", "model.type"), divs = c(0.5, 1.0, 1.5, 2.0))
#' @export
discrimination.scores <- function(df, groups = c("label", "model.type"), divs = c(1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 6.0)) {
  # I don't like it, but for now, 'H3_RMS' and 'scaled_total_score' are hard-coded
  rms_col <- as.name("H3_RMS")
  score_col <- as.name("scaled_total_score")
  
  disc.scores <- df %>% 
    group_by_(.dots = groups) %>% 
    dplyr::summarize_(disc.score = interp(~disc.score(x_col_name, y_col_name, divs), 
                                          .values = c(x_col_name = rms_col, y_col_name = score_col)))
  
  disc.scores$disc.score <- format(disc.scores$disc.score, digits = 2)
  return(disc.scores)
}
