
# *************************************************
#                 Funnel Plot
# *************************************************

#' Generate a funnel plot for a rosetta simulation
#'
#' @param df Data frame containing the score data from a set of 
#'        models generated by Rosetta
#' @param x_val Name of the column in the data.frame with RMSD data
#' @param y_val Name of the column in the data.frame with score data
#' @param n_col Number of columns to use if faceting is required 
#' (i.e. if there is more than one target in the data.frame)
#' @param disc.scores A data.frame containing the discrimination score for each 
#' target in df. If this is provided, the discrimination score will be printed
#' in the lower right side of the plot panel for each target
#' @param color_col Name of the column in df to color points by
#' @param colors A vector of colors to use if you do not want ggplot to pick
#' them for you. Named values can be given
#' @return A funnel plot in a ggplot object 
#' @examples
#' p2 <- funnel_plot(score.data, "H3_RMS", "total_score", n_col = 5, 
#'                   disc.scores = discrimination.scores,
#'                   color_col = "base_geom", colors = c("KINKED" = "orange", 
#'                                                       "UNCLEAR" = "grey", 
#'                                                       "EXTENDED" = "black"))
#' @export
funnel_plot <- function(df, x_val, y_val, n_col = 1, disc.scores=data.frame(),
                        color_col = "", colors = c()) {
  
  # right now this is hard-coded to my personal use case, but 
  font_size <- 10
  p <- ggplot(data = df, aes_string(x = x_val, y = y_val, color = color_col)) +
    geom_point(position = "jitter", size = 1.25) + 
    scale_x_continuous("RMSD (Ã…)", breaks = pretty_breaks(n = 4)) +
    expand_limits(x = 0) +
    facet_wrap(~ label, ncol = n_col, scales = "free") + 
    theme(axis.text.x = element_text(size = font_size),
          axis.text.y = element_text(size = font_size),
          axis.title = element_text(face = "plain", size = font_size + 2),
          strip.background = element_blank())
    
  # use the colors that were passed in
  if (length(levels(as.factor(score.data[[color_col]]))) == length(colors)) {
    # we can use the colors specified by the user!
    p <- p + scale_color_manual(values = colors)
  } else if (length(colors)){
    print(paste("Length of colors does not match the number of levels in ",  
                color_col, ". Letting ggplot pick the colors.", ssep = ""))
  }
  
  # include the discrimination score in the lower right of the panel
  if (nrow(disc.scores)) {
    p <- p + geom_text(aes(x = Inf, y = -Inf, label = paste(disc.score, "\n", 
                                                        sep = "")), 
                   # ggplot's ratio between geom_text and point size is 5/14
                   # who knows why
                   data = disc.scores, size = font_size * (5/14),
                   hjust = 1, vjust = 0.45, color = "black")
  }
  
  native_name <- "nat_score"
  y_lims <- c(NA, NA)
  y_breaks <- pretty_breaks(n = 4)
  
  if (y_val == "scaled.score") {
    native_name <- "scaled.nat.score"
    y_lims <- c(-1, 1)
    y_breaks <- seq(-1, 1, 0.5)
  }
  
  p <- p + geom_hline(aes_string(yintercept = native_name), linetype = "dashed") +
    scale_y_continuous("Score", limits = y_lims, breaks = y_breaks)
  return(p)
}